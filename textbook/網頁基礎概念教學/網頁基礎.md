# 網頁基礎 (Web前端技術應用講義)

## 為什麼要學網頁基礎?

隨著網際網路的普及與應用，網頁已成為資訊傳遞、商業活動與社交互動的重要平台。了解網頁基礎不僅有助於個人技能提升，還能促進職業發展，因為許多行業都需要具備網頁相關知識的人才。


## 我們會學到什麼?

- HTML：網頁的結構與內容標記語言，負責定義文字、圖片、連結等元素的呈現方式。
- CSS：網頁的樣式與佈局設計語言，用於控制顏色、字型、排版與響應式設計。
- JavaScript：網頁的互動與行為控制語言，使網頁能夠響應使用者操作，實現動態效果與功能。
- 前端與後端基礎：了解前端（使用者介面）與後端（伺服器邏輯）的分工與協作方式。

## 學會這些技能後，你將能夠：
- 建立基本的靜態網頁，展示文字、圖片與多媒體內容。
- 使用 CSS 設計美觀且響應式的網頁佈局，適應不同裝置與螢幕尺寸。
- 實作基本的 JavaScript 互動功能，如表單驗證、按鈕事件與動態內容更新。
- 理解前端與後端的基本概念，為進一步學習全端開發打下基礎。


## 前端? 後端?

### 前端（Front-end）

前端（Front-end）是使用者直接互動的那一層，負責把資料與功能以可視、可操作的介面呈現給使用者。簡單來說，前端關注「看得到、按得到、感覺到」的部分。

主要職責
- 建構頁面結構（HTML）：語意化標記、內容組織。
- 設計樣式（CSS）：排版、顏色、響應式設計、佈局（Flex/Grid）。
- 實作互動（JavaScript）：事件處理、DOM 操作、資料繫結、客戶端邏輯。
- 與後端通訊：透過 HTTP/REST、GraphQL、WebSocket 等取得或同步資料。
- 優化使用者體驗（UX）：效能、可及性、相容性、流暢度與可用性。

常見技術與工具
- 框架／函式庫：React、Vue、Angular、Svelte 等，用於組件化與狀態管理。
- 打包與建構工具：Webpack、Vite、Parcel、Rollup。
- CSS 生態：Sass/LESS、PostCSS、CSS Modules、Tailwind 等。
- 開發者工具：瀏覽器 DevTools、Lighthouse、ESLint、Prettier、測試工具（Jest、Cypress）。
- 版本控制與部署：Git、CI/CD、Netlify、Vercel 等。

注意重點
- 漸進增強與優雅降級：確保不同能力的瀏覽器與使用者都有可用體驗。
- 可及性（a11y）：語意標籤、ARIA、鍵盤操作與螢幕閱讀器支援。
- 效能：減少初次載入（Critical Rendering Path）、資源分割、快取策略、影像優化。
- 安全：前端也要注意 XSS、CSRF（與後端合作防護）、內容安全政策（CSP）。
- 測試與維護：元件測試、整合測試、效能監測與可觀察性。

何時需要前端工程師
- 需要直觀 UI、複雜互動、或優化跨裝置體驗時由前端主導；若還要處理伺服器邏輯、資料庫與 API，則會與後端協同或由全端（Full‑stack）負責。
- 前端不只寫外觀，也需要考量使用者情境、可及性與整體效能。 


### 後端（Back-end）

後端是支援前端的伺服器端層，負責資料處理、商業邏輯、資料庫存取與系統整合。使用者看不到後端，但它提供 API、驗證、資料永久化、工作排程與系統安全等關鍵功能。

主要職責
- 提供與管理 API（REST、GraphQL、gRPC）供前端或第三方存取資料與功能。  
- 資料存取與持久化：關聯式資料庫（Postgres、MySQL）或 NoSQL（MongoDB、Redis）。  
- 認證與授權：登入、權限驗證、Token 管理（JWT、OAuth）。  
- 商業邏輯與資料驗證：處理應用規則、輸入驗證、錯誤處理。  
- 背景工作與排程：處理批次任務、發信、影像處理等（Celery、Sidekiq、Bull）。  
- 可觀察性：日誌、指標、追蹤（Logging、Prometheus、Sentry）。  
- 安全性與備援：加密、速率限制、備份、災難復原。

常見技術棧
- 語言／框架：Node.js（Express、Koa、Nest）、Python（Django、Flask、FastAPI）、Java（Spring）、.NET、Go、Ruby on Rails、PHP（Laravel）。  
- 資料庫：PostgreSQL、MySQL、MongoDB、Redis。  
- 基礎建設：Docker、Kubernetes、CI/CD（GitHub Actions、GitLab CI）、IaC（Terraform）。  
- 通訊：HTTP/HTTPS、WebSocket、gRPC、消息佇列（RabbitMQ、Kafka）。

最佳實務（摘要）
- 永遠針對不信任的輸入做驗證與消毒。  
- 密碼用強雜湊（bcrypt/scrypt/argon2），敏感資料加密。  
- 使用 HTTPS 與安全標頭，避免明文憑證。  
- 實作速率限制、錯誤處理與審計日誌。  
- 設計可擴展的 API 與資料模型，並做好監控與自動化部署。

何時需要後端工程師
- 需要永久儲存或關聯資料、處理使用者認證、實作複雜商業邏輯、或與第三方系統整合時由後端主導；高效能或可擴展需求也需要後端設計與運維能力。

簡單範例（Python + Flask）
```python
# 簡單的 REST API 範例（Flask）
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/api/items', methods=['GET'])
def get_items():
    # 從資料庫讀取（此處省略 DB 連線）
    return jsonify([{'id': 1, 'name': '範例項目'}])

@app.route('/api/login', methods=['POST'])
def login():
    data = request.get_json() or {}
    # 驗證（示意，生產環境請實作真實驗證與密碼雜湊）
    if data.get('username') == 'user' and data.get('password') == 'pass':
        return jsonify({'token': 'eyJ...'})
    return jsonify({'error': 'Invalid credentials'}), 401

if __name__ == '__main__':
    app.run(port=3000, debug=True)
```


## 從零開始,建立一個Python Flask後端伺服器

### 參考檔案

請參考專案中的 Flask 開發伺服器範例檔（例如：flask_app.py 或 backend/app.py）。該檔案示範如何建立 Flask app、註冊基本路由（如 /api/items、/api/login）並以開發模式啟動（例如 `app.run(port=3000, debug=True)`）。  
執行範例：`python flask_app.py`（建議在虛擬環境中執行）。


## 怎麼寫一個前端網頁?

1. HTML
2. CSS
3. Javascript


## HTML
HTML（HyperText Markup Language）是前端網頁的基礎語言，用於定義網頁的結構和內容。它通過標籤（如 `<h1>`、`<p>`、`<a>`）來組織文字、圖片、鏈接等元素，形成網頁的骨架。HTML 不負責樣式或互動，而是提供語義化的內容，讓瀏覽器能夠正確渲染和顯示網頁。

### 基本標籤說明：
- `<html>`：整個 HTML 文件的根元素，包含 `<head>` 與 `<body>`。
- `<head>`：放置文件的 metadata（元資料）與外部資源連結，如 `<meta>`、`<title>`、`link`、`style`、`script`（通常放置非立即執行或使用 `defer/async` 的腳本）。
- `<meta>`：提供文件的描述性資訊，常見用途：`<meta charset="utf-8">`（字符編碼）、`<meta name="viewport" content="width=device-width, initial-scale=1">`（響應式設定）。
- `<title>`：瀏覽器分頁或書籤顯示的頁面標題，位於 `<head>` 內。
- `<style>`：在文件內嵌寫 CSS 樣式，通常放在 `<head>`，也可放在其他位置（但較不推薦）。
- `<script>`：包含或引入 JavaScript，控制互動與行為。通常可放在 `<head>`（搭配 `defer` 或 `async`）或放在 `<body>` 底部以避免阻塞渲染。
- `<body>`：放置所有可見的頁面內容（文字、圖片、表單等），瀏覽器會將其渲染給使用者。

簡單範例：
```html
<!doctype html>
<html lang="zh-Hant">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>範例頁面</title>
        <style>
            body { font-family: sans-serif; }
        </style>
    </head>
    <body>
        <h1>標題</h1>
        <p>這是一個簡單的網頁結構示範。</p>
        <script>
            console.log('腳本執行');
        </script>
    </body>
</html>
```

說明：
```html
<meta name="viewport" content="width=device-width, initial-scale=1">
```

說明：
- 這行 meta 用來告訴行動瀏覽器的「版面視窗（layout viewport）」該如何設定。預設（沒有這行）很多行動瀏覽器會使用一個寬度較大的虛擬視窗（例如約 980 CSS px），然後把整個頁面縮小以適配實際裝置，導致原本為桌面設計的版面在手機上被壓縮顯示。
- content 中的參數：
  - `width=device-width`：把版面視窗的寬度設為裝置的 CSS 寬度（即裝置寬度的「CSS 像素」），使得 CSS 的寬度檢測（例如 `@media`）能夠反映真實裝置大小。
  - `initial-scale=1`：初始縮放比例設為 1，表示 1 CSS px 對應於畫面上的 1 個 CSS 像素（不自動縮放）。
- 為什麼響應式網頁要加：
  - 若無此標籤，媒體查詢（如 `@media (max-width: 600px)`）可能永遠不會在手機上觸發，因為瀏覽器先把頁面當成寬螢幕再縮小顯示，導致響應式樣式失效。
  - 有了這行，開發者可依真實裝置寬度（而非瀏覽器模擬的大視窗）設計版面，行為更可預期。
- 常見補充與注意事項（gotchas）：
  - 不要輕易用 `user-scalable=no` 或把 `maximum-scale` 設太小，這會阻止使用者放大，影響可及性。
  - high-DPI 裝置（如 Retina）仍有 devicePixelRatio 的存在：CSS px 與實際硬體像素數量不同，這是正常且與 meta 設定無關。
  - 若需支援瀏海 / 圓角螢幕，可能會加入 `viewport-fit=cover` 並搭配 CSS 的 safe-area-inset 處理。
  - 某些舊版 Android / iOS 行為差異（例如 `shrink-to-fit`），在極端版面需求下需要特別測試。
- 建議基本用法（可直接放在 head）：
  - `<meta name="viewport" content="width=device-width, initial-scale=1">`
  - 如需支援瀏海區域：`<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">`



### 與佈局相關的標籤說明
#### `<div>`

- 定義與特性：
    - 區塊級（block-level）無語義容器，用來分組或包裹內容與子元素。
    - 預設為 display: block；會佔滿可用寬度並換行。
    - 本身不傳達語意，瀏覽器與輔助工具無特別語意化資訊。

- 常見用途：
    - 當作佈局容器（wrapper、container、row、column）。
    - 分隔樣式區域（styling hooks）與 JavaScript 操作的掛載點。
    - 在沒有合適語義元素時作為替代。

- 屬性與可存取性建議：
    - 常用屬性：class、id、data-*（資料屬性）、style（不推薦內聯）、role、aria-*。
    - 儘量優先使用語義標籤（header、nav、main、section、article、aside、footer）以利可及性與 SEO。
    - 若用 div 表示重要區塊，補上適當 role（例如 role="region" 並加 aria-label）以便輔助技術辨識。
    - 若把 div 當互動控制項，請改用本來的互動標籤（button、a），或至少加 tabindex、role 和鍵盤事件處理，並處理 focus 樣式。

- 使用上的最佳實務：
    - 避免過度的「div soup」：當有語意標籤可用時優先使用。
    - class 名稱應具描述性（如 .site-header、.product-list），不是單純位置（如 .left1）。
    - 讓 CSS 處理布局（Flexbox / Grid），HTML 保持結構單純。
    - 小的可重複元件可以用具有語意的容器（section/article）包裹，再在內部使用 div 作樣式取得最大彈性。

- 簡短範例：作為彈性容器的 div
```html
<div class="container">
    <header class="site-header">...</header>
    <main class="main-content">...</main>
    <footer class="site-footer">...</footer>
</div>

<style>
.container { display: flex; flex-direction: column; min-height: 100vh; }
.main-content { flex: 1; }
</style>
```

- 何時不要用 div：
    - 需要表達文章段落、標題、導航、表單等語意時，不應以 div 取代語意標籤。
    - 建立可及性互動元件時，優先使用原生互動元素而非模擬（div + JS）。
    
簡單記憶：div 是通用容器，但不是語意元素，盡量用語意標籤，必要時用 div 做樣式或結構包裝並補上可及性說明。


### `<p>`（段落）

- 定義：表示一段語意性的文字內容（段落），屬於區塊級（block-level）元素，主要用來包裹「phrasing content」（文字、inline 元素、連結、強調等）。
- 用途：用於文章段落、說明文字、列表前後的普通段落等。不要用 `<p>` 當作純粹的版面容器或替代標題（標題應使用 `<h1>`–`<h6>`）。
- 可包含的內容：文字、`<a>`、`<strong>`、`<em>`、`<span>`、`<img>`（作為 inline）等行內元素（phrasing content）。
- 不可包含：其他區塊元素（例如 `<div>`、`<section>`、`<article>`、`ul`、`h1` 等）。若需要把區塊元素放入段落，請改為重構 HTML（使區塊在段落外部）。

瀏覽器行為與樣式習慣
- 瀏覽器通常對 `<p>` 加上預設上下 margin（例如 margin-top/ bottom），可用 CSS 調整：
    - 建議使用 CSS 控制段落間距（例如 `p { margin: 0 0 1rem; }`）。
- 若需強制換行可用 `<br>`，但不建議用 `<br>` 取代段落分段（應以多個 `<p>` 表示多段內容）。

可及性與語意
- `<p>` 能為讀屏器與搜尋引擎提供語意化段落資訊，改善可及性與 SEO。
- 若段落屬於特定語意區塊（例如文章內的引言），可搭配語意標籤（`<article>`、`<section>`、`<aside>`）或使用 `<p class="lead">` 加強語意與樣式。

最佳實務
- 用 `<p>` 表示自然段落；用語意標籤包裝內容結構。
- 避免用 `<p>` 作為版面容器或互動元件（按鈕、可點擊區域應用 `<button>` 或 `<a>`）。
- 若要在段落中放大型媒體或表格，將那些區塊放在段落外並適當分組。

範例
```html
<article>
    <h2>章節標題</h2>
    <p>這是一段說明文字，包含 <a href="#">連結</a> 與 <strong>強調</strong> 的行內元素。</p>

    <p class="lead">引導段落：用來突顯重要摘要或介紹。</p>

    <!-- 不建議：在 p 中放置區塊元素 -->
    <!-- 錯誤範例：<p><div>區塊內容</div></p> -->
</article>

<style>
p { margin: 0 0 1rem; line-height: 1.6; }
p.lead { font-size: 1.125rem; color: #333; }
</style>
```

### 標題元素（h1 ~ h5）說明與用法

簡介：h1~h5 為語意性的標題元素，用於表示文件或區段的標題階層，協助閱讀者與搜尋引擎了解內容結構。通常按層級由上而下使用（h1 最大、h5 較小）。

h1
- 功能：頁面或文章的主標題（最重要的一級標題）。
- 用法：每頁建議只有一個 h1（代表主要主題），放在內容最上方或 header 中。
- SEO/可及性：搜尋引擎與讀屏器會將 h1 視為頁面主題，有助於語意化索引與導覽。

h2
- 功能：章節標題，分隔主要內容區塊（次於 h1）。
- 用法：在文章中用來建立主要章節或區段，h1 下可有多個 h2。
- 實務：常被用作目錄（TOC）依據。

h3
- 功能：小節標題，用於 h2 之下的更細分內容。
- 用法：當章節需要進一步拆分時使用，保留語意順序。

h4
- 功能：更小的子標題，提供細節層次劃分。
- 用法：用於複雜文件需要多層次標題時；避免過度使用，影響可讀性。

h5
- 功能：較小的標題層級，通常用於元資料或次要小節。
- 用法：僅在需要多層次結構時使用，否則用段落或強調元素替代。

最佳實務與建議
- 維持語意順序：不要跳級（例如直接從 h1 跳到 h4），以利可及性與文件結構一致性。
- 每頁一個 h1：保持頁面主題明確；若使用多個 h1（例如在複數 article 中）需確保語意正確。
- 用 CSS 控制外觀：不要用標題元素僅為樣式目的，若只是視覺效果應保持語意並以 CSS 調整字級/樣式。
- 可及性：標題應描述區塊內容，避免空標題或只用符號；標題文字應具描述性便於導航。
- SEO：標題中適度包含關鍵字，但避免關鍵字堆砌，保持自然可讀。

範例
```html
<article>
    <h1>網站設計入門</h1>
    <h2>HTML 基礎</h2>
    <h3>語意化標籤</h3>
    <h3>結構化內容</h3>
    <h2>CSS 與樣式</h2>
    <h4>排版與佈局</h4>
    <h5>細節調整</h5>
</article>
```


### 佈局語意標籤（Layout elements）— 說明與用法

以下為常見的 HTML 佈局與語意標籤，說明其語意、常見用途與可及性建議。

- `<header>`
    - 語意：區塊或文章的頁首/引導區域，通常包含標題、logo、導覽或搜尋。
    - 用法：可出現在整頁（page header）或每個 `article`/`section` 中。可有多個 `header`。
    - 注意：不要只為了樣式使用；若為整頁 header，放在 `<body>` 或 `<main>` 之前較常見。
    - 範例：
        ```html
        <header class="site-header">
            <h1>網站名稱</h1>
            <p class="tagline">網站描述</p>
        </header>
        ```

- `<nav>`
    - 語意：表示主要導覽區塊（links list），例如主選單、分區導覽、頁內目錄（TOC）。
    - 用法：包一組導覽連結；若頁面有多個導覽（如 footer 的次要連結），可以有多個 `<nav>`，建議加 `aria-label` 區分。
    - 注意：不應把每一個含連結的集合都標為 `nav`，例如文章內的內嵌連結清單不是導航。
    - 範例：
        ```html
        <nav aria-label="主要導覽">
            <ul>
                <li><a href="/">首頁</a></li>
                <li><a href="/about">關於</a></li>
            </ul>
        </nav>
        ```

- `<main>`
    - 語意：頁面主要內容的容器（唯一且重要）。每頁應最多一個 `<main>`。
    - 用法：包住與頁面主題直接相關的內容，通常排除頁首、側欄、頁腳與重複性導航。
    - 可及性：輔助技術可快速跳到 `main`。
    - 範例：
        ```html
        <main id="main" role="main">
            <!-- 主要內容 -->
        </main>
        ```

- `<section>`
    - 語意：語意性的區段（有主題的內容群），通常以標題（h1~h6）開始。
    - 用法：用於內容上有明確主題或章節的地方；可巢狀使用。
    - 注意：不要為了純樣式而使用；若只是分組無語意，考慮用 `div`。
    - 範例：
        ```html
        <section>
            <h2>服務項目</h2>
            <p>描述…</p>
        </section>
        ```

- `<article>`
    - 語意：可獨立存在、適合獨立分發或引用的內容（例如新聞、部落格文章、留言）。
    - 用法：內部可包含 header/footer/section，常含作者與時間等元資料。
    - 注意：若內容會獨立被引用或 RSS 聚合，使用 `article`。
    - 範例：
        ```html
        <article>
            <header><h2>文章標題</h2></header>
            <p>文章內容…</p>
            <footer>作者 / 日期</footer>
        </article>
        ```

- `<aside>`
    - 語意：與主內容「間接相關」的側邊內容（側欄、小工具、補充資訊）。
    - 用法：常放在 `main` 的旁邊或文章內作補充；若放在 `article` 內，表示與該文章相關。
    - 注意：不要把主要內容放入 `aside`。可被視為次要資訊。
    - 範例：
        ```html
        <aside class="sidebar">
            <h3>相關連結</h3>
            <ul>…</ul>
        </aside>
        ```

- `<footer>`
    - 語意：區塊或文章的頁尾，通常包含版權、聯絡資訊或相關連結。
    - 用法：可用於整頁（site footer）或每個 `article` 的結尾。可有多個 `footer`。
    - 範例：
        ```html
        <footer>
            <p>© 2025 公司名稱</p>
        </footer>
        ```

- `<figure>` / `<figcaption>`
    - 語意：`figure` 用於自成一體的媒體（圖片、程式碼片段、圖表）；`figcaption` 用於提供該媒體的說明。
    - 用法：將媒體與其說明包在一起，對可及性與語意化有幫助。
    - 範例：
        ```html
        <figure>
            <img src="chart.png" alt="月銷售圖">
            <figcaption>圖：本年度每月銷售趨勢</figcaption>
        </figure>
        ```

- `<address>`
    - 語意：表示聯絡資訊（作者或組織的聯絡方式），通常包含電子郵件、實體地址或社群連結。
    - 用法：通常放在 `footer` 中表示頁面或文章的聯絡資訊。
    - 範例：
        ```html
        <address>
            聯絡：<a href="mailto:hi@example.com">hi@example.com</a>
        </address>
        ```

- 小結與可及性建議
    - 使用語意標籤能改善可及性、SEO 與維護性；不要把語意標籤僅當作 CSS 容器。
    - 每頁應只有一個 `<main>`；導航應加 `aria-label`（若有多個 `<nav>`）以便辨識。
    - 提供跳過連結（skip link）可讓鍵盤/輔助技術使用者快速進入 `main`。
    - 標題 (h1~h6) 應與 `section` / `article` 搭配，保持文件結構層次分明。

簡短範例（整合常見元素）：
```html
<body>
    <a class="skip-link" href="#main">跳到主要內容</a>
    <header>
        <h1>網站名稱</h1>
        <nav aria-label="主要導覽">…</nav>
    </header>

    <main id="main" role="main">
        <article>
            <header><h2>文章標題</h2></header>
            <p>內容…</p>
            <aside>相關側欄資訊</aside>
            <footer>作者 / 日期</footer>
        </article>

        <section>
            <h2>章節標題</h2>
            <p>章節內容…</p>
        </section>
    </main>

    <footer>網站頁尾資訊</footer>
</body>
```



### 五種常見的 HTML 文件結構範例(補充)
#### 範例 1 — 最簡單的 HTML5 結構
```html
<!doctype html>
<html lang="zh-Hant">
    <head>
        <meta charset="utf-8">
        <title>最簡範例</title>
    </head>
    <body>
        <h1>標題</h1>
        <p>內容</p>
    </body>
</html>
```

#### 範例 2 — 外部 CSS 與延遲載入的 JS（建議用法）
```html
<!doctype html>
<html lang="zh-Hant">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width,initial-scale=1">
        <title>外部資源範例</title>
        <link rel="stylesheet" href="styles.css">
    </head>
    <body>
        <header><h1>網站標題</h1></header>
        <main>
            <p>頁面內容</p>
        </main>
        <script defer src="main.js"></script>
    </body>
</html>
```

#### 範例 3 — 響應式與 SEO 基本頭資訊
```html
<!doctype html>
<html lang="zh-Hant">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width,initial-scale=1">
        <meta name="description" content="簡短描述，有助於搜尋引擎與分享">
        <link rel="canonical" href="https://example.com/page">
        <title>響應式與 SEO</title>
        <link rel="icon" href="/favicon.ico">
        <link rel="stylesheet" href="/css/site.css">
    </head>
    <body>
        <h1>頁面標題</h1>
        <p>內容</p>
        <script defer src="/js/site.js"></script>
    </body>
</html>
```

#### 範例 4 — SPA（單頁應用）與 ES 模組
```html
<!doctype html>
<html lang="zh-Hant">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width,initial-scale=1">
        <title>單頁應用範例</title>
        <link rel="stylesheet" href="/dist/app.css">
        <base href="/">
    </head>
    <body>
        <div id="app"><!-- SPA 範本或掛載點 --></div>
        <noscript>需要啟用 JavaScript 以使用此應用。</noscript>
        <script type="module" src="/dist/app.bundle.js" defer></script>
    </body>
</html>
```

#### 範例 5 — 可及性與漸進增強（skip link、ARIA、no-JS 備援）
```html
<!doctype html>
<html lang="zh-Hant">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width,initial-scale=1">
        <title>可及性範例</title>
        <style>
            .skip-link { position:absolute;left:-999px;top:auto; }
            .skip-link:focus { left:0; top:0; }
        </style>
    </head>
    <body>
        <a class="skip-link" href="#main">跳到主要內容</a>
        <header role="banner">
            <h1>網站標題</h1>
        </header>
        <nav role="navigation" aria-label="主要導覽">
            <ul><li><a href="/">首頁</a></li></ul>
        </nav>
        <main id="main" role="main">
            <h2>內容標題</h2>
            <form action="/search" method="get" aria-label="搜尋表單">
                <label for="q">搜尋：</label>
                <input id="q" name="q" type="search">
                <button type="submit">送出</button>
            </form>
        </main>
        <footer role="contentinfo">
            <p>版權資訊</p>
        </footer>
        <noscript>
            <p>此站部分功能需要 JavaScript，請啟用或使用支援 JavaScript 的瀏覽器。</p>
        </noscript>
        <script defer src="/js/accessible.js"></script>
    </body>
</html>
```


## CSS

### 甚麼是 CSS?
CSS（Cascading Style Sheets，層疊樣式表）是用於控制網頁外觀與排版的樣式語言。它與 HTML 分工合作：HTML 負責內容結構，CSS 負責視覺呈現（顏色、字型、間距、佈局等）。透過 CSS，開發者可以統一管理樣式、實現響應式設計，並大幅提升網頁的美觀性與使用者體驗。

### CSS 的核心概念

- 選擇器（Selectors）：用來指定要套用樣式的 HTML 元素。
    - 元素選擇器：`p { color: blue; }`（所有 `<p>` 標籤）
    - 類別選擇器：`.title { font-size: 2rem; }`（所有 `class="title"` 的元素）
    - ID 選擇器：`#header { background: gray; }`（`id="header"` 的元素）
    - 屬性選擇器、偽類（`:hover`、`:focus`）、偽元素（`::before`、`::after`）等進階用法。

- 屬性與值（Properties & Values）：定義元素的樣式。
    - 例如：`color`、`font-size`、`margin`、`padding`、`background`、`display`、`position` 等。
    - 值可以是顏色（`#fff`、`rgb(255,0,0)`）、長度（`px`、`rem`、`%`）、關鍵字（`auto`、`none`）等。

- 層疊（Cascade）與優先級：當多條規則套用到同一元素時，CSS 會根據特異性（specificity）、來源順序與 `!important` 決定最終樣式。
    - 優先級由高到低：內聯樣式 > ID 選擇器 > 類別/屬性選擇器 > 元素選擇器。
    - 建議：避免過度使用 `!important`，保持選擇器簡潔以利維護。

- 盒模型（Box Model）：每個元素都是一個矩形盒子，由內容（content）、內距（padding）、邊框（border）、外距（margin）組成。
    - 預設：`box-sizing: content-box`（寬度只包含內容）。
    - 建議：使用 `box-sizing: border-box` 讓寬度包含 padding 與 border，計算更直觀。




### 選擇器使用方法說明

#### 基本選擇器（Basic Selectors）

1. **元素選擇器（Type Selector）**
    - 語法：`element { ... }`
    - 說明：選取所有指定標籤名稱的元素。
    - 範例：
      ```css
      p { color: blue; }           /* 所有 <p> 標籤 */
      h1 { font-size: 2rem; }      /* 所有 <h1> 標籤 */
      ```

2. **類別選擇器（Class Selector）**
    - 語法：`.classname { ... }`
    - 說明：選取所有具有指定 `class` 屬性值的元素。可重複使用，一個元素可有多個類別。
    - 範例：
      ```css
      .title { font-weight: bold; }
      .btn { padding: 0.5rem 1rem; }
      ```
      ```html
      <p class="title">標題段落</p>
      <button class="btn">按鈕</button>
      ```

3. **ID 選擇器（ID Selector）**
    - 語法：`#idname { ... }`
    - 說明：選取具有指定 `id` 屬性值的元素。每頁 ID 應唯一，優先級高於類別選擇器。
    - 範例：
      ```css
      #header { background: gray; }
      #main-content { max-width: 1200px; }
      ```
      ```html
      <header id="header">頁首</header>
      ```

4. **通用選擇器（Universal Selector）**
    - 語法：`* { ... }`
    - 說明：選取所有元素，常用於重置樣式。
    - 範例：
      ```css
      * { margin: 0; padding: 0; box-sizing: border-box; }
      ```
    - 注意：過度使用可能影響效能，建議搭配其他選擇器限縮範圍。

#### 屬性選擇器（Attribute Selectors）

選取具有特定屬性或屬性值的元素。

- `[attr]`：元素有此屬性即可。
  ```css
  [disabled] { opacity: 0.5; }
  ```

- `[attr="value"]`：屬性值完全相等。
  ```css
  [type="text"] { border: 1px solid gray; }
  ```

- `[attr~="value"]`：屬性值包含指定單字（以空格分隔）。
  ```css
  [class~="btn"] { cursor: pointer; }
  ```

- `[attr|="value"]`：屬性值以 `value` 開頭且後接 `-` 或完全相等（常用於語言代碼）。
  ```css
  [lang|="zh"] { font-family: "Noto Sans TC"; }
  ```

- `[attr^="value"]`：屬性值以 `value` 開頭。
  ```css
  [href^="https"] { color: green; }
  ```

- `[attr$="value"]`：屬性值以 `value` 結尾。
  ```css
  [href$=".pdf"] { background: url(pdf-icon.png); }
  ```

- `[attr*="value"]`：屬性值包含 `value` 子字串。
  ```css
  [class*="btn"] { padding: 0.5rem; }
  ```

#### 組合選擇器（Combinators）

1. **後代選擇器（Descendant Selector）**
    - 語法：`A B { ... }`（空格分隔）
    - 說明：選取 A 內所有 B 元素（任意層級）。
    - 範例：
      ```css
      .container p { line-height: 1.6; }  /* .container 內所有 <p> */
      ```

2. **子代選擇器（Child Selector）**
    - 語法：`A > B { ... }`
    - 說明：選取 A 的直接子元素 B（僅一層）。
    - 範例：
      ```css
      ul > li { list-style: none; }  /* 僅 <ul> 的直接子 <li> */
      ```

3. **相鄰兄弟選擇器（Adjacent Sibling Selector）**
    - 語法：`A + B { ... }`
    - 說明：選取緊接在 A 之後的第一個 B 兄弟元素。
    - 範例：
      ```css
      h1 + p { font-size: 1.2rem; }  /* <h1> 後的第一個 <p> */
      ```

4. **一般兄弟選擇器（General Sibling Selector）**
    - 語法：`A ~ B { ... }`
    - 說明：選取 A 之後的所有 B 兄弟元素。
    - 範例：
      ```css
      h1 ~ p { color: gray; }  /* <h1> 後的所有 <p> */
      ```

#### 偽類選擇器（Pseudo-classes）

偽類選取元素的特定狀態或位置。

- **互動狀態**
  - `:hover`：滑鼠懸停時。
     ```css
     a:hover { text-decoration: underline; }
     ```
  - `:focus`：元素獲得焦點時（鍵盤或點擊）。
     ```css
     input:focus { border-color: blue; }
     ```
  - `:active`：元素被點擊時（滑鼠按下）。
     ```css
     button:active { transform: scale(0.95); }
     ```

- **結構性偽類**
  - `:first-child`：父元素的第一個子元素。
     ```css
     li:first-child { font-weight: bold; }
     ```
  - `:last-child`：父元素的最後一個子元素。
  - `:nth-child(n)`：父元素的第 n 個子元素（可用公式，如 `2n`、`3n+1`）。
     ```css
     tr:nth-child(even) { background: #f9f9f9; }  /* 偶數行 */
     ```
  - `:nth-last-child(n)`：從最後開始數第 n 個。
  - `:only-child`：唯一子元素。

- **類型性偽類**
  - `:first-of-type`：父元素中第一個該類型的元素。
  - `:last-of-type`：最後一個該類型的元素。
  - `:nth-of-type(n)`：第 n 個該類型的元素。
     ```css
     p:nth-of-type(2) { color: red; }  /* 第二個 <p> */
     ```

- **表單狀態**
  - `:checked`：選中的 checkbox 或 radio。
     ```css
     input:checked + label { color: green; }
     ```
  - `:disabled`：被禁用的表單元素。
  - `:enabled`：可用的表單元素。
  - `:valid` / `:invalid`：表單驗證狀態。

- **其他**
  - `:not(selector)`：排除符合選擇器的元素。
     ```css
     p:not(.exclude) { margin-bottom: 1rem; }
     ```
  - `:root`：文件根元素（HTML），常用於定義 CSS 變數。
     ```css
     :root { --primary: #007bff; }
     ```

#### 偽元素選擇器（Pseudo-elements）

偽元素用於選取元素的特定部分或插入內容，語法使用雙冒號 `::`（單冒號也可但不推薦）。

- `::before`：在元素內容之前插入內容。
  ```css
  .icon::before { content: "★ "; color: gold; }
  ```

- `::after`：在元素內容之後插入內容。
  ```css
  .link::after { content: " →"; }
  ```

- `::first-line`：選取區塊元素的第一行文字。
  ```css
  p::first-line { font-weight: bold; }
  ```

- `::first-letter`：選取區塊元素的第一個字元。
  ```css
  p::first-letter { font-size: 2rem; float: left; }
  ```

- `::selection`：選取使用者反白的文字。
  ```css
  ::selection { background: yellow; color: black; }
  ```

- `::placeholder`：選取表單輸入框的提示文字。
  ```css
  input::placeholder { color: #999; }
  ```

#### 選擇器優先級（Specificity）

當多條規則套用到同一元素時，優先級決定最終樣式。計算方式（由高到低）：

1. **內聯樣式**（`style` 屬性）：1000
2. **ID 選擇器**（`#id`）：100
3. **類別、屬性、偽類**（`.class`、`[attr]`、`:hover`）：10
4. **元素、偽元素**（`p`、`::before`）：1

範例：
```css
/* 優先級：0-0-1-1 = 11 */
div p { color: blue; }

/* 優先級：0-1-0-0 = 100 */
#content { color: red; }

/* 優先級：0-0-2-0 = 20 */
.title.highlight { color: green; }
```

- `!important` 會覆蓋所有優先級，但應避免濫用。
- 相同優先級時，後出現的規則會覆蓋先前的規則（Cascade 原則）。

#### 選擇器最佳實務

1. **保持簡潔**：避免過深巢狀（如 `.a .b .c .d`），降低維護難度與優先級衝突。
2. **語意化命名**：使用描述性的類別名稱（如 `.btn-primary`），而非樣式名稱（如 `.blue`）。
3. **減少 ID 選擇器**：ID 優先級過高，建議多用類別選擇器，保持彈性。
4. **善用組合器**：用子代選擇器（`>`）取代後代選擇器，提升效能與精確度。
5. **避免通用選擇器濫用**：`*` 選擇器會影響所有元素，限縮範圍使用（如 `.container *`）。
6. **測試可及性**：確保 `:focus` 樣式清晰，不移除預設 outline（或提供替代視覺提示）。

#### 綜合範例

```html
<!doctype html>
<html lang="zh-Hant">
<head>
     <meta charset="utf-8">
     <title>選擇器範例</title>
     <style>
          /* 元素選擇器 */
          body { font-family: sans-serif; margin: 0; }
          
          /* 類別選擇器 */
          .container { max-width: 800px; margin: 0 auto; padding: 1rem; }
          .btn { background: #007bff; color: white; padding: 0.5rem 1rem; border: none; cursor: pointer; }
          
          /* ID 選擇器 */
          #header { background: #333; color: white; padding: 1rem; }
          
          /* 屬性選擇器 */
          [type="email"] { border: 2px solid blue; }
          
          /* 偽類 */
          .btn:hover { background: #0056b3; }
          li:nth-child(odd) { background: #f0f0f0; }
          
          /* 偽元素 */
          .title::before { content: "📌 "; }
          
          /* 組合器 */
          .container > p { color: gray; }  /* 直接子元素 */
          h1 + p { font-size: 1.1rem; }    /* 相鄰兄弟 */
     </style>
</head>
<body>
     <header id="header">網站標題</header>
     <div class="container">
          <h1 class="title">選擇器範例</h1>
          <p>第一段落（h1 的相鄰兄弟）</p>
          <p>第二段落</p>
          <ul>
                <li>項目 1（奇數背景）</li>
                <li>項目 2（偶數無背景）</li>
                <li>項目 3（奇數背景）</li>
          </ul>
          <input type="email" placeholder="電子郵件">
          <button class="btn">送出</button>
     </div>
</body>
</html>
```



### 引入 CSS 的三種方式

1. 外部樣式表（推薦）：將 CSS 寫在獨立檔案中，透過 `<link>` 引入。
     ```html
     <link rel="stylesheet" href="styles.css">
     ```
     優點：可重複使用、易於維護、可快取。

2. 內部樣式表：在 HTML 的 `<head>` 中使用 `<style>` 標籤。
     ```html
     <style>
             body { font-family: sans-serif; }
     </style>
     ```
     適用於單頁樣式或快速測試。

3. 內聯樣式：直接在 HTML 元素上使用 `style` 屬性。
     ```html
     <p style="color: red;">內聯樣式</p>
     ```
     不推薦：難以維護、優先級高、無法重複使用。

### 常見佈局技術

- Flexbox（彈性盒模型）：用於一維排列（水平或垂直）。
    ```css
    .container { display: flex; justify-content: center; align-items: center; }
    ```
    適合導航列、卡片排列、置中對齊等。

- Grid（網格佈局）：用於二維排列（行與列）。
    ```css
    .grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; }
    ```
    適合複雜版面、響應式網格。

- 定位（Positioning）：`static`（預設）、`relative`、`absolute`、`fixed`、`sticky`。
    - `absolute`：相對於最近的定位祖先。
    - `fixed`：相對於視窗固定。

### 響應式設計

- 媒體查詢（Media Queries）：根據螢幕寬度、裝置類型調整樣式。
    ```css
    @media (max-width: 768px) {
            .container { flex-direction: column; }
    }
    ```

- 流動佈局：使用百分比、`rem`、`vw`/`vh` 等相對單位，避免固定像素寬度。

- 可變字級與間距：使用 `clamp()`、`calc()` 或 CSS 自定義屬性實現彈性調整。

### CSS 最佳實務

- 保持選擇器簡潔：避免過深巢狀（例如 `.a .b .c .d`），降低特異性衝突。
- 使用語意化類別名稱：如 `.btn-primary`、`.card-header`，而非 `.blue-box`。
- 模組化與重複使用：將常見樣式抽成類別（utility classes）或元件樣式。
- 使用 CSS 變數（Custom Properties）：方便主題切換與維護。
    ```css
    :root { --primary-color: #007bff; }
    .button { background: var(--primary-color); }
    ```
- 效能優化：最小化 CSS、移除未使用樣式（使用工具如 PurgeCSS）、避免過多重繪。
- 可及性：確保顏色對比度符合 WCAG 標準、`:focus` 樣式清晰、不依賴純顏色傳達資訊。

### 進階工具與生態

- 預處理器：Sass、LESS、Stylus，提供變數、巢狀、mixins 等功能。
- PostCSS：模組化的 CSS 處理工具，可搭配 Autoprefixer、cssnano 等插件。
- CSS 框架：Bootstrap、Tailwind CSS、Bulma 等，提供預製樣式與元件。
- CSS-in-JS：在 JavaScript 中撰寫樣式（如 styled-components、Emotion），適合元件化開發。

### 簡單範例

```html
<!doctype html>
<html lang="zh-Hant">
<head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>CSS 範例</title>
        <style>
                body { font-family: sans-serif; margin: 0; padding: 0; }
                .container { max-width: 800px; margin: 0 auto; padding: 2rem; }
                h1 { color: #333; }
                .btn { background: #007bff; color: white; padding: 0.5rem 1rem; border: none; border-radius: 4px; cursor: pointer; }
                .btn:hover { background: #0056b3; }
        </style>
</head>
<body>
        <div class="container">
                <h1>歡迎使用 CSS</h1>
                <button class="btn">按鈕範例</button>
        </div>
</body>
</html>
```

### 常用CSS排版技巧與屬性

#### 範例 1：自傳履歷格式（響應式單欄佈局）

```html
<!doctype html>
<html lang="zh-Hant">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>個人履歷</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: sans-serif; line-height: 1.6; color: #333; background: #f9f9f9; }
        
        .resume-container {
            max-width: 800px;
            margin: 2rem auto;
            background: white;
            padding: 2rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            border-bottom: 2px solid #007bff;
            padding-bottom: 1rem;
            margin-bottom: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .header img {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 1rem;
            border: 4px solid #007bff;
        }
        
        .header h1 { font-size: 2rem; margin-bottom: 0.5rem; }
        .header p { color: #666; font-size: 0.95rem; }
        
        .section {
            margin-bottom: 2rem;
        }
        
        .section h2 {
            font-size: 1.5rem;
            color: #007bff;
            border-left: 4px solid #007bff;
            padding-left: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .section p { margin-bottom: 0.75rem; }
        
        .skills-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            list-style: none;
        }
        
        .skills-list li {
            background: #e7f3ff;
            color: #007bff;
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        
        .experience-item {
            margin-bottom: 1.5rem;
            padding-left: 1rem;
            border-left: 2px solid #ddd;
        }
        
        .experience-item h3 {
            font-size: 1.2rem;
            margin-bottom: 0.25rem;
        }
        
        .experience-item .date {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }
        
        /* 響應式:手機版調整 */
        @media (max-width: 600px) {
            .resume-container { padding: 1.5rem; margin: 1rem; }
            .header h1 { font-size: 1.5rem; }
            .header img { width: 120px; height: 120px; }
            .section h2 { font-size: 1.25rem; }
        }
    </style>
</head>
<body>
    <div class="resume-container">
        <header class="header">
            <img src="https://www.shiningshot.com/wp-content/uploads/2024/03/%E8%89%BE%E5%A6%83%E6%8B%89%E5%BD%B1%E5%83%8F-%E9%9F%93%E5%BC%8F%E8%AD%89%E4%BB%B6%E7%85%A71-796x1024.webp" alt="個人照片">
            <h1>張小明</h1>
            <p>前端工程師 | example@email.com | 0912-345-678</p>
        </header>
        
        <section class="section">
            <h2>自我介紹</h2>
            <p>熱愛網頁開發，擁有三年前端經驗，熟悉 HTML、CSS、JavaScript 及現代框架。注重使用者體驗與可及性，善於團隊協作與問題解決。</p>
        </section>
        
        <section class="section">
            <h2>專業技能</h2>
            <ul class="skills-list">
                <li>HTML5 / CSS3</li>
                <li>JavaScript (ES6+)</li>
                <li>React / Vue</li>
                <li>響應式設計</li>
                <li>Git / GitHub</li>
                <li>Webpack / Vite</li>
            </ul>
        </section>
        
        <section class="section">
            <h2>工作經歷</h2>
            <div class="experience-item">
                <h3>前端工程師 — ABC 科技公司</h3>
                <p class="date">2021/06 - 至今</p>
                <p>負責企業官網與內部系統前端開發，使用 React 建構可重複使用的元件，優化頁面載入速度並實作響應式設計。</p>
            </div>
            <div class="experience-item">
                <h3>網頁設計實習生 — XYZ 工作室</h3>
                <p class="date">2020/09 - 2021/05</p>
                <p>協助設計與開發小型專案網站，學習前端基礎與協作流程。</p>
            </div>
        </section>
        
        <section class="section">
            <h2>學歷</h2>
            <p><strong>國立○○大學</strong> — 資訊管理學系 (2016-2020)</p>
        </section>
    </div>
</body>
</html>
```

---

#### 範例 2：部落格首頁格式（側邊選單 + 響應式）

```html
<!doctype html>
<html lang="zh-Hant">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>我的部落格</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: sans-serif; line-height: 1.6; color: #333; }
        
        /* 頂部導航 */
        .topbar {
            background: #007bff;
            color: white;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .topbar h1 { 
            font-size: 1.5rem; 
            margin: 0;
        }
        
        .topbar-nav {
            display: flex;
            gap: 2rem;
            list-style: none;
            margin: 0;
            padding: 0;
        }
        
        .topbar-nav li a {
            color: white;
            text-decoration: none;
            font-size: 1rem;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .topbar-nav li a:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .menu-toggle {
            display: none;
            background: transparent;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        /* 側邊選單 (僅手機版) */
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 250px;
            height: 100vh;
            background: #2c3e50;
            color: white;
            padding: 5rem 1.5rem 1.5rem;
            transition: transform 0.3s ease;
            z-index: 999;
            transform: translateX(-100%);
        }
        
        .sidebar.visible {
            transform: translateX(0);
        }
        
        .sidebar nav ul {
            list-style: none;
        }
        
        .sidebar nav ul li {
            margin-bottom: 1rem;
        }
        
        .sidebar nav ul li a {
            color: white;
            text-decoration: none;
            font-size: 1.1rem;
            display: block;
            padding: 0.5rem;
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .sidebar nav ul li a:hover {
            background: #34495e;
        }
        
        .close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: transparent;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        /* 主要內容區 */
        .main-content {
            margin-left: 0;
            padding: 2rem;
            padding-top: 6rem; /* 為固定的頂部導航留空間 */
            transition: margin-left 0.3s ease;
        }
        
        .post-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
        }
        
        .post-card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .post-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .post-card h2 {
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
            color: #007bff;
        }
        
        .post-card .meta {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 0.75rem;
        }
        
        .post-card p {
            color: #555;
            margin-bottom: 1rem;
        }
        
        .post-card a {
            color: #007bff;
            text-decoration: none;
            font-weight: bold;
        }
        
        /* 響應式:平板與手機 */
        @media (max-width: 768px) {
            .topbar {
                padding: 1rem;
            }
            
            .topbar-nav {
                display: none; /* 手機版隱藏頂部導航,改用側邊欄 */
            }
            
            .sidebar {
                transform: translateX(-100%);
            }
            
            .sidebar.visible {
                transform: translateX(0);
            }
            
            .main-content {
                margin-left: 0;
                padding-top: 5rem;
            }
            
            .menu-toggle {
                display: block;
            }
            
            .post-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- 頂部導航 -->
    <header class="topbar">
        <h1>我的部落格</h1>
        <nav>
            <ul class="topbar-nav">
                <li><a href="#home">首頁</a></li>
                <li><a href="#tech">技術文章</a></li>
                <li><a href="#life">生活紀錄</a></li>
                <li><a href="#projects">專案作品</a></li>
                <li><a href="#about">關於我</a></li>
            </ul>
        </nav>
        <button class="menu-toggle" id="menuToggle">☰</button>
    </header>
    
    <!-- 側邊選單 (僅手機版) -->
    <aside class="sidebar" id="sidebar">
        <button class="close-btn" id="closeBtn">✕</button>
        <nav>
            <ul>
                <li><a href="#home">首頁</a></li>
                <li><a href="#tech">技術文章</a></li>
                <li><a href="#life">生活紀錄</a></li>
                <li><a href="#projects">專案作品</a></li>
                <li><a href="#about">關於我</a></li>
            </ul>
        </nav>
    </aside>
    
    <!-- 主要內容 -->
    <main class="main-content" id="mainContent">
        <h2>最新文章</h2>
        <div class="post-grid">
            <article class="post-card">
                <h2>如何學習前端開發</h2>
                <p class="meta">2025/01/15 | 技術</p>
                <p>前端開發入門指南，涵蓋 HTML、CSS、JavaScript 基礎與學習路徑建議...</p>
                <a href="#">閱讀更多 →</a>
            </article>
            
            <article class="post-card">
                <h2>CSS Flexbox 完整教學</h2>
                <p class="meta">2025/01/10 | 技術</p>
                <p>深入淺出介紹 Flexbox 排版原理與實務應用，包含常見佈局範例...</p>
                <a href="#">閱讀更多 →</a>
            </article>
            
            <article class="post-card">
                <h2>我的開發工具推薦</h2>
                <p class="meta">2025/01/05 | 生活</p>
                <p>分享日常使用的編輯器、插件與效率工具，提升開發體驗...</p>
                <a href="#">閱讀更多 →</a>
            </article>
            
            <article class="post-card">
                <h2>響應式設計要點</h2>
                <p class="meta">2024/12/28 | 技術</p>
                <p>RWD 設計原則與媒體查詢實務，確保網站在各裝置正常顯示...</p>
                <a href="#">閱讀更多 →</a>
            </article>
        </div>
    </main>
    
    <script>
        const menuToggle = document.getElementById('menuToggle');
        const sidebar = document.getElementById('sidebar');
        const closeBtn = document.getElementById('closeBtn');
        const mainContent = document.getElementById('mainContent');
        
        // 手機版:點擊漢堡選單顯示側邊欄
        menuToggle.addEventListener('click', () => {
            sidebar.classList.add('visible');
        });
        
        // 手機版:點擊關閉按鈕隱藏側邊欄
        closeBtn.addEventListener('click', () => {
            sidebar.classList.remove('visible');
        });
        
        // 手機版:點擊主內容區關閉選單
        mainContent.addEventListener('click', () => {
            if (sidebar.classList.contains('visible')) {
                sidebar.classList.remove('visible');
            }
        });
        
        // 點擊側邊欄內的連結後自動關閉選單
        const sidebarLinks = sidebar.querySelectorAll('a');
        sidebarLinks.forEach(link => {
            link.addEventListener('click', () => {
                sidebar.classList.remove('visible');
            });
        });
    </script>
</body>
</html>
```

**說明重點：**

範例 1（履歷）：
- 單欄佈局，使用 `max-width` 限制寬度並置中。
- 使用語意化標籤（`header`、`section`）與邊框裝飾增強視覺層次。
- 技能列表使用 Flexbox 包裝，響應式自動換行。
- 手機版縮小字級與間距，保持可讀性。

範例 2（部落格）：
- 固定側邊選單（`position: fixed`），桌面版永久顯示，手機版預設隱藏。
- 主內容區使用 CSS Grid 建立響應式卡片排列（`auto-fill` + `minmax`）。
- JavaScript 控制選單顯示/隱藏，搭配 CSS 過渡效果（`transition`）。
- 媒體查詢在 768px 以下切換為手機版行為（漢堡選單 + 全寬內容）。
- 選單外點擊或關閉按鈕可收合選單，提升使用體驗。


## JavaScript

### JavaScript 用途是甚麼?
JavaScript 是一種高階、解釋型的程式語言，主要用於網頁開發。它的用途包括：
- **動態效果**：為網頁添加互動性和動態效果，例如動畫、表單驗證等。
- **客戶端邏輯**：在用戶的瀏覽器中執行程式碼，減少伺服器負擔，提高響應速度。
- **AJAX 請求**：與伺服器進行非同步通信，實現無刷新頁面更新。
- **前端框架**：支援各種前端框架（如 React、Vue、Angular），提升開發效率。
- **全端開發**：透過 Node.js 等技術，JavaScript 也可用於伺服器端開發。

### 甚麼是靜態網頁與動態網頁?
- **靜態網頁**：內容固定不變的網頁，每次訪問時顯示相同的內容。通常由 HTML 和 CSS 組成，適合展示資訊性內容，如個人簡介、產品介紹等。
- **動態網頁**：內容可根據用戶互動或其他條件改變的網頁。通常使用 JavaScript 或伺服器端語言（如 PHP、Node.js）來生成動態內容，適合需要頻繁更新或互動的應用，如社交媒體、電子商務平台等。


### JavaScript 基本語法與範例


#### 基本語法概念

**變數宣告**
- `let`：可重新賦值的區塊作用域變數（推薦）。
- `const`：不可重新賦值的區塊作用域常數（推薦用於不變值）。
- `var`：函式作用域變數（舊語法，不推薦）。

```javascript
let name = "小明";
const age = 25;
var city = "台北"; // 不推薦使用

name = "小華"; // 可以修改
// age = 30; // 錯誤：const 不可重新賦值
```

**資料型別**
- **原始型別**：`string`（字串）、`number`（數字）、`boolean`（布林值）、`null`、`undefined`、`symbol`、`bigint`。
- **物件型別**：`object`、`array`、`function`。

```javascript
let str = "Hello";           // 字串
let num = 42;                // 數字
let bool = true;             // 布林值
let empty = null;            // 空值
let notDefined;              // undefined
let arr = [1, 2, 3];         // 陣列
let obj = { name: "小明" };  // 物件
```

**運算子**
- **算術運算子**：`+`、`-`、`*`、`/`、`%`（餘數）、`**`（次方）。
- **比較運算子**：`==`（寬鬆相等）、`===`（嚴格相等）、`!=`、`!==`、`>`、`<`、`>=`、`<=`。
- **邏輯運算子**：`&&`（且）、`||`（或）、`!`（非）。
- **賦值運算子**：`=`、`+=`、`-=`、`*=`、`/=`。

```javascript
let a = 10, b = 5;
console.log(a + b);  // 15
console.log(a === 10); // true
console.log(a > 5 && b < 10); // true
```

**條件判斷**
```javascript
let score = 85;

if (score >= 90) {
    console.log("優秀");
} else if (score >= 60) {
    console.log("及格");
} else {
    console.log("不及格");
}

// 三元運算子
let result = score >= 60 ? "及格" : "不及格";
```

**迴圈**
```javascript
// for 迴圈
for (let i = 0; i < 5; i++) {
    console.log(i);
}

// while 迴圈
let count = 0;
while (count < 3) {
    console.log(count);
    count++;
}

// for...of（遍歷陣列）
let arr = [1, 2, 3];
for (let item of arr) {
    console.log(item);
}

// for...in（遍歷物件屬性）
let obj = { a: 1, b: 2 };
for (let key in obj) {
    console.log(key, obj[key]);
}
```

**函式**
```javascript
// 函式宣告
function greet(name) {
    return `你好，${name}！`;
}

// 函式表達式
const add = function(a, b) {
    return a + b;
};

// 箭頭函式（Arrow Function）
const multiply = (a, b) => a * b;

console.log(greet("小明"));    // 你好，小明！
console.log(add(2, 3));        // 5
console.log(multiply(4, 5));   // 20
```

**陣列操作**
```javascript
let fruits = ["蘋果", "香蕉", "橘子"];

// 新增元素
fruits.push("芒果");           // 尾端新增
fruits.unshift("草莓");        // 開頭新增

// 刪除元素
fruits.pop();                  // 刪除尾端
fruits.shift();                // 刪除開頭

// 遍歷陣列
fruits.forEach(item => console.log(item));

// 陣列方法
let numbers = [1, 2, 3, 4, 5];
let doubled = numbers.map(n => n * 2);        // [2, 4, 6, 8, 10]
let filtered = numbers.filter(n => n > 2);    // [3, 4, 5]
let sum = numbers.reduce((acc, n) => acc + n, 0); // 15
```

**物件操作**
```javascript
let person = {
    name: "小明",
    age: 25,
    greet: function() {
        console.log(`我是 ${this.name}`);
    }
};

// 存取屬性
console.log(person.name);      // 小明
console.log(person["age"]);    // 25

// 新增/修改屬性
person.city = "台北";
person.age = 26;

// 刪除屬性
delete person.city;

// 物件方法
person.greet(); // 我是 小明
```

**DOM 操作**
```javascript
// 選取元素
let title = document.getElementById("title");
let items = document.querySelectorAll(".item");

// 修改內容
title.textContent = "新標題";
title.innerHTML = "<strong>粗體標題</strong>";

// 修改樣式
title.style.color = "red";
title.classList.add("active");

// 事件監聽
let button = document.querySelector("button");
button.addEventListener("click", function() {
    alert("按鈕被點擊了！");
});
```

**事件處理**
```javascript
// 點擊事件
document.querySelector(".btn").addEventListener("click", () => {
    console.log("按鈕被點擊");
});

// 表單提交事件
document.querySelector("form").addEventListener("submit", (event) => {
    event.preventDefault(); // 阻止預設提交行為
    console.log("表單已提交");
});

// 鍵盤事件
document.addEventListener("keydown", (event) => {
    console.log(`按下的鍵：${event.key}`);
});
```

**非同步處理（Promise 與 async/await）**
```javascript
// Promise
fetch("https://api.example.com/data")
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error(error));

// async/await
async function fetchData() {
    try {
        let response = await fetch("https://api.example.com/data");
        let data = await response.json();
        console.log(data);
    } catch (error) {
        console.error(error);
    }
}
```

**錯誤處理**
```javascript
try {
    let result = riskyOperation();
    console.log(result);
} catch (error) {
    console.error("發生錯誤：", error.message);
} finally {
    console.log("無論如何都會執行");
}
```

**模組化（ES6 Modules）**

JavaScript 模組化是將程式碼拆分成可重複使用的獨立檔案，透過 `export` 與 `import` 語法進行匯出與匯入。ES6 模組（ESM）是現代 JavaScript 的標準模組系統，支援靜態分析、樹搖（tree-shaking）優化，並在瀏覽器與 Node.js 中廣泛使用。

---

#### 為什麼需要模組化？

- **程式碼組織**：將功能拆分成獨立檔案，提升可讀性與維護性。
- **重複使用**：同一模組可在多處匯入使用，避免重複撰寫。
- **命名空間隔離**：每個模組有獨立作用域，避免全域變數污染。
- **依賴管理**：明確模組間的依賴關係，便於追蹤與除錯。
- **效能優化**：支援按需載入（lazy loading）與樹搖（移除未使用程式碼）。

---

#### ES6 模組基本語法

**1. 匯出（export）**

有兩種主要匯出方式：**具名匯出（named export）** 與 **預設匯出（default export）**。

**具名匯出**
```javascript
// math.js
export const PI = 3.14159;
export const E = 2.71828;

export function add(a, b) {
    return a + b;
}

export function multiply(a, b) {
    return a * b;
}
```

也可以集中匯出：
```javascript
// math.js
const PI = 3.14159;
const E = 2.71828;

function add(a, b) {
    return a + b;
}

function multiply(a, b) {
    return a * b;
}

export { PI, E, add, multiply };
```

**預設匯出**
每個模組只能有一個預設匯出，通常用於模組的主要功能。
```javascript
// calculator.js
export default function calculate(a, b, operator) {
    switch (operator) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return a / b;
        default: return 0;
    }
}
```

**混合匯出**
```javascript
// utils.js
export const version = "1.0.0";

export default function formatDate(date) {
    return date.toISOString().split('T')[0];
}
```

---

**2. 匯入（import）**

**匯入具名匯出**
```javascript
// app.js
import { PI, add, multiply } from "./math.js";

console.log(PI);              // 3.14159
console.log(add(2, 3));       // 5
console.log(multiply(4, 5));  // 20
```

**匯入所有具名匯出（命名空間匯入）**
```javascript
import * as math from "./math.js";

console.log(math.PI);         // 3.14159
console.log(math.add(2, 3));  // 5
```

**匯入預設匯出**
```javascript
import calculate from "./calculator.js";

console.log(calculate(10, 5, '+')); // 15
```

**混合匯入**
```javascript
import formatDate, { version } from "./utils.js";

console.log(version);                    // 1.0.0
console.log(formatDate(new Date()));     // 2025-01-20
```

**重新命名匯入**
```javascript
import { add as addition, multiply as times } from "./math.js";

console.log(addition(2, 3)); // 5
console.log(times(4, 5));    // 20
```

---

#### 動態匯入（Dynamic Import）

ES6 模組支援動態匯入（`import()`），回傳 Promise，適合按需載入或條件載入。

```javascript
// 按需載入模組
async function loadMath() {
    const math = await import("./math.js");
    console.log(math.add(2, 3)); // 5
}

loadMath();
```

**使用情境**
- 路由切換時載入對應元件（React、Vue）。
- 根據條件載入不同功能模組。
- 減少初始載入體積，提升效能。

範例：
```javascript
const button = document.querySelector("#loadBtn");

button.addEventListener("click", async () => {
    const { default: calculator } = await import("./calculator.js");
    console.log(calculator(10, 5, '+'));
});
```

---

#### 模組化的歷史演進

在 ES6 之前，JavaScript 沒有原生模組系統,社群發展出多種模組化方案：

**1. IIFE（立即執行函式表達式）**
```javascript
// 早期模組化：透過閉包隔離作用域
const myModule = (function() {
    const privateVar = "私有變數";
    
    function privateFunction() {
        console.log(privateVar);
    }
    
    return {
        publicFunction: function() {
            privateFunction();
        }
    };
})();

myModule.publicFunction(); // 私有變數
```

**優點**：簡單、隔離作用域。  
**缺點**：無法管理依賴、手動維護載入順序、全域命名空間污染。

---

**2. CommonJS（Node.js 模組系統）**

CommonJS 是 Node.js 的預設模組系統，使用 `require()` 與 `module.exports`。

```javascript
// math.js（CommonJS）
const PI = 3.14;

function add(a, b) {
    return a + b;
}

module.exports = { PI, add };
```

```javascript
// app.js
const math = require("./math.js");

console.log(math.PI);        // 3.14
console.log(math.add(2, 3)); // 5
```

**特性**
- **同步載入**：適合伺服器端，不適合瀏覽器。
- **動態載入**：可在條件語句中使用 `require()`。
- **不支援靜態分析**：無法進行樹搖優化。

---

**3. AMD（Asynchronous Module Definition）**

AMD 是為瀏覽器設計的非同步模組系統，代表實作為 RequireJS。

```javascript
// math.js（AMD）
define(function() {
    return {
        PI: 3.14,
        add: function(a, b) {
            return a + b;
        }
    };
});
```

```javascript
// app.js
require(["math"], function(math) {
    console.log(math.PI);        // 3.14
    console.log(math.add(2, 3)); // 5
});
```

**特性**
- **非同步載入**：適合瀏覽器環境。
- **複雜語法**：定義與使用較繁瑣。

---

**4. UMD（Universal Module Definition）**

UMD 是為了兼容 CommonJS、AMD 與全域變數的混合方案。

```javascript
(function(root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define([], factory);
    } else if (typeof module === 'object' && module.exports) {
        // CommonJS
        module.exports = factory();
    } else {
        // 全域變數
        root.myModule = factory();
    }
}(typeof self !== 'undefined' ? self : this, function() {
    return {
        add: function(a, b) { return a + b; }
    };
}));
```

**特性**
- **最大兼容性**：可在多種環境執行。
- **語法複雜**：難以維護。

---

**5. ES6 Modules（ESM）**

ES6 模組是 JavaScript 的官方標準，兼具靜態分析與非同步載入優勢。

**特性對比**
| 特性 | CommonJS | AMD | ES6 Modules |
|------|----------|-----|-------------|
| 載入方式 | 同步 | 非同步 | 靜態/非同步 |
| 環境 | Node.js | 瀏覽器 | 通用 |
| 樹搖優化 | ✗ | ✗ | ✓ |
| 靜態分析 | ✗ | ✗ | ✓ |
| 語法簡潔度 | 中 | 低 | 高 |

---

#### 在瀏覽器中使用 ES6 模組

**HTML 引入模組**
```html
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="utf-8">
    <title>ES6 模組範例</title>
</head>
<body>
    <h1>模組化示範</h1>
    <script type="module" src="app.js"></script>
</body>
</html>
```

**注意事項**
- 需使用 `type="module"` 屬性。
- 模組預設為嚴格模式（`"use strict"`）。
- 模組有獨立作用域，不會污染全域變數。
- 需透過 HTTP(S) 協定載入（本地需使用 Live Server 或 Web 伺服器）。

---

#### 在 Node.js 中使用 ES6 模組

**方法 1：在 package.json 中設定**
```json
{
  "type": "module"
}
```

**方法 2：使用 .mjs 副檔名**
```javascript
// math.mjs
export const add = (a, b) => a + b;
```

```javascript
// app.mjs
import { add } from "./math.mjs";
console.log(add(2, 3)); // 5
```

---

#### 模組化最佳實務

1. **單一職責原則**：每個模組應專注於單一功能。
2. **命名一致性**：檔案名稱應與匯出內容相關（如 `utils.js`、`api.js`）。
3. **避免循環依賴**：模組 A 匯入 B，B 又匯入 A 會導致問題。
4. **優先具名匯出**：預設匯出會導致重新命名不一致，具名匯出更明確。
5. **使用樹搖優化**：透過打包工具（Webpack、Vite）移除未使用程式碼。
6. **動態載入大型模組**：使用 `import()` 按需載入，減少初始載入時間。

---

#### 完整範例

**專案結構**
```
project/
├── index.html
├── app.js
├── math.js
└── utils.js
```

**math.js**
```javascript
export const PI = 3.14159;

export function add(a, b) {
    return a + b;
}

export function multiply(a, b) {
    return a * b;
}
```

**utils.js**
```javascript
export default function formatDate(date) {
    return date.toISOString().split('T')[0];
}

export const version = "1.0.0";
```

**app.js**
```javascript
import { PI, add, multiply } from "./math.js";
import formatDate, { version } from "./utils.js";

console.log(`版本：${version}`);
console.log(`PI = ${PI}`);
console.log(`2 + 3 = ${add(2, 3)}`);
console.log(`4 × 5 = ${multiply(4, 5)}`);
console.log(`今天日期：${formatDate(new Date())}`);
```

**index.html**
```html
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="utf-8">
    <title>模組化範例</title>
</head>
<body>
    <h1>開啟主控台查看結果</h1>
    <script type="module" src="app.js"></script>
</body>
</html>
```

**執行結果（主控台）**
```
版本：1.0.0
PI = 3.14159
2 + 3 = 5
4 × 5 = 20
今天日期：2025-01-20
```

---

#### 總結

- **ES6 模組**是現代 JavaScript 的標準模組系統，語法簡潔且支援靜態分析。
- **具名匯出**適合匯出多個功能，**預設匯出**適合模組主要功能。
- **動態匯入**可按需載入模組,減少初始載入時間。
- 瀏覽器需使用 `type="module"`，Node.js 需設定 `"type": "module"` 或使用 `.mjs`。
- 模組化演進：IIFE → CommonJS/AMD → UMD → ES6 Modules。
- 遵循最佳實務可提升程式碼品質與維護性。



**最佳實務建議**
- 優先使用 `const`，需要重新賦值才用 `let`，避免使用 `var`。
- 使用 `===` 而非 `==`，避免型別轉換問題。
- 使用箭頭函式簡化語法，但注意 `this` 的綁定行為。
- 善用陣列方法（`map`、`filter`、`reduce`）處理資料。
- 使用 `async/await` 處理非同步操作，程式碼更易讀。
- 為互動元素加上事件監聽器，避免內聯事件（如 `onclick="..."`）。
- 使用 `try...catch` 捕捉錯誤，避免程式崩潰。
